package org.dieschnittstelle.mobile.android.apps.contenttagger.controller;

import android.app.Fragment;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBarActivity;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.EditText;

import org.dieschnittstelle.mobile.android.apps.contenttagger.R;
import org.dieschnittstelle.mobile.android.apps.contenttagger.model.Note;
import org.dieschnittstelle.mobile.android.components.controller.LifecycleHandling;
import org.dieschnittstelle.mobile.android.components.controller.MainNavigationControllerActivity;
import org.dieschnittstelle.mobile.android.components.events.Event;
import org.dieschnittstelle.mobile.android.components.events.EventDispatcher;
import org.dieschnittstelle.mobile.android.components.events.EventGenerator;
import org.dieschnittstelle.mobile.android.components.events.EventListener;
import org.dieschnittstelle.mobile.android.components.events.EventListenerOwner;
import org.dieschnittstelle.mobile.android.components.events.EventMatcher;

/**
 * Created by master on 17.03.16.
 *
 * we realise the readview as a subclass of the editview that does some settings on the latter's constituents and provides its own actionset
 */
public class NotesReadviewFragment extends NotesEditviewFragment implements EventGenerator, EventListenerOwner {

    protected static String logger = "NotesReadviewFragment";


    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = super.onCreateView(inflater, container, savedInstanceState);

        // we remove the borders from the fields
        title.setBackgroundDrawable(getResources().getDrawable(android.R.color.transparent));
        ((View)content.getParent()).setBackgroundDrawable(getResources().getDrawable(android.R.color.transparent));
        content.setPadding(0, 0, 0, 0);
        // we set the fields as not editable, but with normal text color - could be dealt with usin a selector at xml level
        title.setEnabled(false);
        title.setTextColor(getResources().getColor(R.color.abc_primary_text_material_dark));
        content.setEnabled(false);
        content.setTextColor(getResources().getColor(R.color.abc_primary_text_material_dark));

        tagsbarController.setRemoveActive(false);

        return view;
    }

    protected boolean isEditable() {
        return false;
    }

    protected void addEventListeners() {
        // set listeners
        EventDispatcher.getInstance().addEventListener(this, new EventMatcher(Event.CRUD.TYPE, Event.OR(Event.CRUD.DELETED), Note.class), false, new EventListener<Note>() {
            @Override
            public void onEvent(Event<Note> event) {
                if (note == event.getData()) {
                    // in case the note is deleted, we mark this as obsolete
                    Log.i(logger, "note has been deleted. mark myself as obsolete...");
                    obsolete = true;
                } else {
                    Log.i(logger, "onEvent(): got " + event.getType() + " event for note, but it involves a different object than the one being edited: " + event.getData() + ". Ignore...");
                }
            }
        });

        // also handle read events that are generated by ourselves
        EventDispatcher.getInstance().addEventListener(this, new EventMatcher(Event.CRUD.TYPE, Event.OR(Event.CRUD.READ, Event.CRUD.UPDATED), Note.class, this), true, new EventListener<Note>() {
            @Override
            public void onEvent(Event<Note> event) {
                note = event.getData();
                ((ActionBarActivity) getActivity()).setTitle(note.getTitle());
                title.setText(note.getTitle());
                content.setText(note.getContent());
                // we create the tagbar controller new on update
                tagsbarController.bindTaggable(note);
                attachmentsController.bindTaggable(note);
            }
        });

    }

    @Override
    public void onResume() {
        super.onResume();
//        ((ActionBarActivity)getActivity()).setTitle(R.string.title_read_note);
        // TODO: obsoletion could be dealt with at framework level within LifecycleHandling.onResume()
        if (obsolete) {
            Log.i(logger,"view is obsolete. Pop from backstack...");
            getFragmentManager().popBackStack();
        }
    }

    public void onPause() {
        super.onPause();
        LifecycleHandling.onPause(this);
    }

    public void onDestroy() {
        super.onDestroy();
        LifecycleHandling.onDestroy(this);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.getItemId() == R.id.action_edit) {
            ((MainNavigationControllerActivity) getActivity()).showView(NotesEditviewFragment.class, MainNavigationControllerActivity.createArguments(NotesEditviewFragment.ARG_NOTE_ID, note.getId()), true);
            return true;
        }
        else if (item.getItemId() == R.id.action_share) {
            Intent sendIntent = new Intent();
            sendIntent.setAction(Intent.ACTION_SEND);
            sendIntent.putExtra(Intent.EXTRA_SUBJECT,"[contenttagger] " + this.note.getTitle());
            sendIntent.putExtra(Intent.EXTRA_TEXT, this.note.getContent() + "\n\n [sent from contenttagger@android]");
            sendIntent.setType("text/plain");
            startActivity(sendIntent);
        }
        return super.onOptionsItemSelected(item);
    }

    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        // we do NOT invoke super as this will the super actions...
        //super.onCreateOptionsMenu(menu, inflater);
        inflater.inflate(R.menu.menu_notes_readview, menu);
    }

}
